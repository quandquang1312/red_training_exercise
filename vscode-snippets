{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Template": {
		"prefix": "_template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"",
			"int32_t main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr); cout.tie(nullptr);",
			"",
			"    #ifdef LOCAL",
			"        freopen(\"in.txt\", \"r\", stdin);",
			"        freopen(\"ou.txt\", \"w\", stdout);",
			"    #endif",
			"",
			"    return 0;",
			"}"
		]
	},

	"Coordinate Compress": {
		"prefix": "_coor",
		"body": [
			"vector<int> points;",
			"",
			"// Coordinate Compression",
			"sort(points.begin(), points.end());",
			"points.erase(unique(points.begin(),points.end()), points.end());",
			"int sz = points.size();",
			"",
			"unordered_map<int, int> idx;",
			"for (int i=1; i<=sz; i++) idx[points[i-1]] = i;"
		],
		"description": "Coordinate Compress"
	},

	"Minimum spanning tree": {
		"prefix": "_mst",
		"body": [
			"vector<tuple<int, int, int>> EL;",
			"",
			"sort(EL.begin(), EL.end());",
			"",
			"DSU dsu(n + 1);",
			"",
			"int mst = 0, cnt = 0;",
			"for (auto &[w, u, v] : EL) {",
			"    if (dsu.isSameSet(u, v)) continue;",
			"",
			"    mst += w;",
			"    cnt++;",
			"",
			"    if (cnt == n - 1) break;",
			"}"
		],
		"description": "Minimum spanning tree"
	},

	"Dijkstra": {
		"prefix": "_dijkstra",
		"body": [
			"vector<int> dijkstra(int st, vector<vector<pair<int, int>>>& graph) {",
			"    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
			"    pq.push({0, st});",
			"",
			"    int n = graph.size();",
			"",
			"    vector<int> dist(n + 1, INF);",
			"    dist[st] = 0;",
			"",
			"    while (!pq.empty()) {",
			"        auto [d, u] = pq.top();",
			"        pq.pop();",
			"",
			"        if (d > dist[u]) continue;",
			"",
			"        for (auto [v, w] : graph[u]) {",
			"            if (d + w < dist[v]) {",
			"                dist[v] = d + w;",
			"                pq.push({dist[v], v});",
			"            }",
			"        }",
			"    }",
			"",
			"    return dist;",
			"}"
		],
		"description": "Dijkstra"
	},

	"DSU": {
	"prefix": "_dsu",
	"body": [
		"class DSU {",
		"private:",
		"    vector<int> p, rank, setSize;",
		"    int numSets;",
		"",
		"public:",
		"    DSU(int n) {",
		"        p.assign(n, 0);",
		"        for (int i=0; i<n; i++) p[i] = i;",
		"",
		"        rank.assign(n, 0);",
		"        setSize.assign(n, 1);",
		"        numSets = n;",
		"    }",
		"",
		"    int findSet(int i) {",
		"        if (p[i] == i) return i;",
		"        return p[i] = findSet(p[i]);",
		"    }",
		"",
		"    bool isSameSet(int i, int j) {",
		"        return findSet(i) == findSet(j);",
		"    }",
		"",
		"    int sizeOfSet(int i) {",
		"        return setSize[findSet(i)];",
		"    }",
		"",
		"    int numOfSets() {",
		"        return numSets;",
		"    }",
		"",
		"    void unionSet(int i, int j) {",
		"        if (isSameSet(i, j)) return;",
		"",
		"        int x = findSet(i);",
		"        int y = findSet(j);",
		"",
		"        if (rank[x] > rank[y]) swap(x, y);",
		"",
		"        p[x] = y;",
		"        if (rank[x] == rank[y]) rank[y]++;",
		"",
		"        setSize[y] += setSize[x];",
		"        --numSets;",
		"    }",
		"};"
	],
	"description": "Disjoin Set Union"
	},

	"LCA": {
		"prefix": "_lca",
		"body": [
			"class LCA {",
			"public:",
			"    int n, maxLog;",
			"    vector<vector<pair<int,int>>> tree;",
			"    vector<vector<int>> parent;",
			"    vector<int> depth, dist;",
			"",
			"    LCA(int n) : n(n) {",
			"        tree.resize(n);",
			"        depth.assign(n, 0);",
			"        dist.assign(n, 0);",
			"",
			"        maxLog = 32 - __builtin_clz(n);",
			"        parent.assign(n, vector<int>(maxLog, -1));",
			"    }",
			"",
			"    void addEdge(int u, int v, int w) {",
			"        tree[u].push_back({v, w});",
			"        tree[v].push_back({u, w});",
			"    }",
			"",
			"    void dfs(int u, int p, int d, int d2) {",
			"        depth[u] = d;",
			"        dist[u] = d2;",
			"        parent[u][0] = p;",
			"        for (auto &edge : tree[u]) {",
			"            int v = edge.first, w = edge.second;",
			"            if (v != p) {",
			"                dfs(v, u, d + 1, d2 + w);",
			"            }",
			"        }",
			"    }",
			"",
			"    void buildSparseTable() {",
			"        for (int j = 1; j < maxLog; j++) {",
			"            for (int i = 0; i < n; i++) {",
			"                if (parent[i][j - 1] != -1) {",
			"                    parent[i][j] = parent[parent[i][j - 1]][j - 1];",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    void build(int root = 0) {",
			"        dfs(root, -1, 0, 0);",
			"        buildSparseTable();",
			"    }",
			"",
			"    int lca(int u, int v) {",
			"        if (depth[u] < depth[v]) swap(u, v);",
			"",
			"        int diff = depth[u] - depth[v];",
			"        for (int i = 0; i < maxLog; i++) {",
			"            if (diff & (1 << i)) u = parent[u][i];",
			"        }",
			"        ",
			"        if (u == v) return u;",
			"",
			"        for (int i = maxLog - 1; i >= 0; i--) {",
			"            if (parent[u][i] != -1 && parent[u][i] != parent[v][i]) {",
			"                u = parent[u][i];",
			"                v = parent[v][i];",
			"            }",
			"        }",
			"        ",
			"        return parent[u][0];",
			"    }",
			"    ",
			"    int distance(int u, int v) {",
			"        int l = lca(u, v);",
			"        return dist[u] + dist[v] - 2 * dist[l];",
			"    }",
			"};"
		],
		"description": "LCA"
	},
	
	"Matrix": {
		"prefix": "_matrix",
		"body": [
		  "class Matrix {",
		  "public:",
		  "    vector<vector<long long>> mat;",
		  "    int n_rows, n_cols;",
		  "",
		  "    Matrix(int n_rows, int n_cols) : n_rows(n_rows), n_cols(n_cols) {",
		  "        mat.resize(n_rows, vector<long long>(n_cols, 0));",
		  "    }",
		  "",
		  "    static Matrix identity_matrix(int n) {",
		  "        Matrix I(n, n);",
		  "        for (int i = 0; i < n; i++) {",
		  "            I.mat[i][i] = 1;",
		  "        }",
		  "        return I;",
		  "    }",
		  "",
		  "    Matrix operator*(const Matrix &other) const {",
		  "        int n = n_rows, m = other.n_cols;",
		  "        Matrix result(n, m);",
		  "        for (int i = 0; i < n; i++) {",
		  "            for (int j = 0; j < m; j++) {",
		  "                for (int k = 0; k < n_cols; k++) {",
		  "                    result.mat[i][j] += mat[i][k] * other.mat[k][j];",
		  "                    result.mat[i][j] %= MOD;",
		  "                }",
		  "            }",
		  "        }",
		  "        return result;",
		  "    }",
		  "",
		  "    Matrix pow(long long power) const {",
		  "        Matrix result = identity_matrix(n_rows);",
		  "        Matrix base = *this;",
		  "        while (power > 0) {",
		  "            if (power & 1) {",
		  "                result = result * base;",
		  "            }",
		  "            base = base * base;",
		  "            power >>= 1;",
		  "        }",
		  "        return result;",
		  "    }",
		  "};",
		  "",
		  "long long calculate_Gn(long long n, int c, int d) {",
		  "    Matrix trans(2, 2);",
		  "    trans.mat = {{1, 2}, {1, 0}};",
		  "",
		  "    Matrix state(2, 1);",
		  "    state.mat = {{c}, {d}};",
		  "",
		  "    state = trans.pow(n - 1) * state;",
		  "",
		  "    return state.mat[0][0];",
		  "}"
		],
		"description": "Matrix"
	},

	"Combinatorics Small K": {
		"prefix": "_cnk2",
		"body": [
			"// When K is relatively small compared to N",
			"int CnK(int n, int k) {",
			"    if (k > n) return 0LL;",
			"    if (k == n) return 1LL;",
			"",
			"    k = min(k, n - k);",
			"",
			"    int numerator = 1, denominator = 1;",
			"    for (int i=0; i<k; i++) {",
			"        numerator = (numerator * (n - i) % MOD) % MOD;",
			"        denominator = (denominator * (i + 1) % MOD) % MOD;",
			"    }",
			"",
			"    int denominator_inv = binpow(denominator, MOD - 2);",
			"    return (numerator * denominator_inv) % MOD;",
			"}"
		],
		"description": "Combinatorics Small K"
	},

	"Combinatorics Large K": {
		"prefix": "_cnk1",
		"body": [
			"int inv(int n) {",
			"    return binpow(n, MOD - 2LL);",
			"}",
			"",
			"void precalF() {",
			"    f[0] = f[1] = 1;",
			"    for (int i=2; i<MAXN; i++) f[i] = (f[i - 1] * i) % MOD;",
			"}",
			"",
			"int CnK(int n, int k) {",
			"    if (n == k) return 1LL;",
			"    if (n < k) return 0LL;",
			"",
			"    return ((f[n] * inv(f[k]) % MOD) * (inv(f[n-k])) % MOD) % MOD;",
			"}"
		],
		"description": "Combinatorics Large K"
	},

	"Segment Tree Greater": {
		  "prefix": "_stgreater",
		  "body": [
		    "// https://codeforces.com/contest/459/problem/D",
		    "",
		    "#include <bits/stdc++.h>",
		    "using namespace std;",
		    "",
		    "class SegmentTree {",
		    "private:",
		    "    vector<vector<int>> tree;",
		    "    int n;",
		    "",
		    "    void build(const vector<int>& arr, int node, int start, int end) {",
		    "        if (start == end) {",
		    "            tree[node] = { arr[start] };",
		    "        } else {",
		    "            int mid = (start + end) / 2;",
		    "            int leftChild = 2 * node + 1;",
		    "            int rightChild = 2 * node + 2;",
		    "            build(arr, leftChild, start, mid);",
		    "            build(arr, rightChild, mid + 1, end);",
		    "            merge(tree[leftChild].begin(), tree[leftChild].end(),",
		    "                  tree[rightChild].begin(), tree[rightChild].end(),",
		    "                  back_inserter(tree[node]));",
		    "        }",
		    "    }",
		    "",
		    "    int query(int node, int start, int end, int l, int r, int x) {",
		    "        if (r < start || end < l) {",
		    "            return 0;",
		    "        }",
		    "        if (l <= start && end <= r) {",
		    "            return tree[node].end() - upper_bound(tree[node].begin(), tree[node].end(), x);",
		    "        }",
		    "        int mid = (start + end) / 2;",
		    "        int leftChild = 2 * node + 1;",
		    "        int rightChild = 2 * node + 2;",
		    "        return query(leftChild, start, mid, l, r, x) + query(rightChild, mid + 1, end, l, r, x);",
		    "    }",
		    "",
		    "public:",
		    "    SegmentTree(const vector<int>& arr) {",
		    "        n = arr.size();",
		    "        tree.resize(4 * n);",
		    "        build(arr, 0, 0, n - 1);",
		    "    }",
		    "",
		    "    int query(int l, int r, int x) {",
		    "        return query(0, 0, n - 1, l, r, x);",
		    "    }",
		    "};",
		    "",
		    "int32_t main() {",
		    "    ios_base::sync_with_stdio(false);",
		    "    cin.tie(nullptr); cout.tie(nullptr);",
		    "",
		    "    #ifdef LOCAL",
		    "        freopen(\"in.txt\", \"r\", stdin);",
		    "        freopen(\"ou.txt\", \"w\", stdout);",
		    "    #endif",
		    "",
		    "    int n; cin >> n;",
		    "    vector<int> arr(n);",
		    "",
		    "    unordered_map<int, int> cnt;",
		    "    int trace2[n+1];",
		    "    vector<int> trace1(n+1);",
		    "    for (int i=0; i<n; i++) {",
		    "        cin >> arr[i];",
		    "        cnt[arr[i]]++;",
		    "        trace1[i] = cnt[arr[i]];",
		    "    }",
		    "",
		    "    for (int i=0; i<n; i++) {",
		    "        trace2[i] = cnt[arr[i]];",
		    "        cnt[arr[i]]--;",
		    "        if (cnt[arr[i]] == 0) cnt.erase(arr[i]);",
		    "    }",
		    "",
		    "    cnt.clear();",
		    "",
		    "    SegmentTree segTree(trace1);",
		    "    long long res = 0LL;",
		    "    for (int i=n-1; i>=0; i--) {",
		    "        long long tmp = segTree.query(0, i-1, trace2[i]);",
		    "        res += tmp;",
		    "    }",
		    "",
		    "    cout << res << endl;",
		    "",
		    "    return 0;",
		    "}"
		  ],
		  "description": "Segment Tree Greater"
	},

	"Fenwick Tree": {
		"prefix": "_fenwick_tree",
		"body": [
		  "class FenwickTree {",
		  "public:",
		  "    FenwickTree(int n) {",
		  "        this->n = n;",
		  "        ft.assign(n, 0);",
		  "    }",
		  "",
		  "    FenwickTree(vector<int> arr) : FenwickTree(arr.size()) {",
		  "        for (int i=0; i<arr.size(); i++)",
		  "            add(i, arr[i]);",
		  "    }",
		  "",
		  "    int query(int l, int r) {",
		  "        return sum(r) - sum(l-1);",
		  "    }",
		  "",
		  "    void add(int idx, int vl) {",
		  "        for (; idx < n; idx = idx | (idx + 1))",
		  "            ft[idx] += vl;",
		  "    }",
		  "",
		  "private:",
		  "    vector<int> ft;",
		  "    int n;",
		  "",
		  "private:",
		  "    int g(int i) { return i & (i + 1); }",
		  "    int sum(int i) {",
		  "        int rs = 0;",
		  "        while (i >= 0) {",
		  "            rs += ft[i];",
		  "            i = g(i) - 1;",
		  "        }",
		  "        return rs;",
		  "    }",
		  "};",
		],
		"description": "Segment Tree"
	},

	"Segment Tree": {
		"prefix": "_segment_tree",
		"body": [
			"class SegmentTree {",
			"private:",
			"    int n;",
			"    vector<int> tree;",
			"",
			"    int merge(int a, int b) {",
			"        return min(a, b);",
			"    }",
			"",
			"    void update(int node, int tl, int tr, int pos, int val) {",
			"        if (tl == tr) {",
			"            tree[node] += val;",
			"        } else {",
			"            int tm = (tl + tr) / 2;",
			"            if (pos <= tm)",
			"                update(node*2, tl, tm, pos, val);",
			"            else",
			"                update(node*2+1, tm+1, tr, pos, val);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"    int query(int node, int tl, int tr, int l, int r) {",
			"        if (l > r) return 0;",
			"        if (l == tl && r == tr) {",
			"            return tree[node];",
			"        }",
			"        int tm = (tl + tr) / 2;",
			"        return merge(query(node*2, tl, tm, l, min(r, tm)),",
			"               query(node*2+1, tm+1, tr, max(l, tm+1), r));",
			"    }",
			"",
			"public:",
			"    SegmentTree(int sz) : n(sz) {",
			"        tree.assign(4 * n, 0);",
			"    }",
			"",
			"    void update(int pos, int val) {",
			"        update(1, 1, n, pos, val);",
			"    }",
			"",
			"    int query(int l, int r) {",
			"        return query(1, 1, n, l, r);",
			"    }",
			"};"
		],
		"description": "Segment Tree"
	},

	"Lazy Segment Tree 0-based": {
		"prefix": "_lazy_segment_tree_add_0-based",
		"body": [
			"class SegmentTree { // 0-based index segment tree with lazy update",
			"private:",
			"    int n;",
			"    vector<int> tree, lazy, arr;",
			"",
			"    void build(int node, int tl, int tr) {",
			"        if (tl == tr) tree[node] = arr[tl];",
			"        else {",
			"            int tm = (tl + tr) >> 1;",
			"            build(node*2+1, tl, tm);",
			"            build(node*2+2, tm+1, tr);",
			"            tree[node] = merge(tree[node*2+1], tree[node*2+2]);",
			"        }",
			"    }",
			"",
			"    int merge(int a, int b) {",
			"        return a + b; // sum segment tree",
			"    }",
			"",
			"    int query(int node, int l, int r, int tl, int tr) {",
			"        if (l > r) return 0;",
			"        push(node, tl, tr); ",
			"        if (l == tl && r == tr) return tree[node];",
			"        int tm = (tl + tr) >> 1;",
			"        return merge(query(node*2+1, l, min(r, tm), tl, tm),",
			"                    query(node*2+2, max(l, tm+1), r, tm+1, tr));",
			"    }",
			"",
			"    void push(int node, int tl, int tr) {",
			"        if (lazy[node]) {",
			"            tree[node] += lazy[node] * (tr - tl + 1);",
			"            if (tl != tr) {",
			"                lazy[node*2+1] += lazy[node];",
			"                lazy[node*2+2] += lazy[node];",
			"            }",
			"            lazy[node] = 0;",
			"        }",
			"    }",
			"",
			"    void update(int node, int pos, int tl, int tr, int val) {",
			"        if (tl == tr) tree[node] += val;",
			"        else {",
			"            int tm = (tl + tr) >> 1;",
			"            push(node, tl, tr);",
			"            if (pos <= tm) update(node*2+1, pos, tl, tm, val);",
			"            else update(node*2+2, pos, tm+1, tr, val);",
			"            tree[node] = merge(tree[node*2+1], tree[node*2+2]);",
			"        }",
			"    }",
			"",
			"    void rangeUpdate(int node, int l, int r, int tl, int tr, int val) {",
			"        if (l > r) return;",
			"        if (l == tl && r == tr) {",
			"            lazy[node] += val;",
			"            push(node, tl, tr);",
			"        } else {",
			"            int tm = (tl + tr) >> 1;",
			"            push(node, tl, tr);",
			"            rangeUpdate(node*2+1, l, min(r, tm), tl, tm, val);",
			"            rangeUpdate(node*2+2, max(l, tm+1), r, tm+1, tr, val);",
			"            tree[node] = merge(tree[node*2+1], tree[node*2+2]);",
			"        }",
			"    }",
			"",
			"public:",
			"    SegmentTree(int sz) {",
			"        n = sz;",
			"        arr.resize(n, 0);",
			"        tree.resize(4 * n, 0);",
			"        lazy.resize(4 * n, 0);",
			"    }",
			"",
			"    int query(int l, int r) {",
			"        return query(0, l, r, 0, n-1);",
			"    }",
			"",
			"    void update(int pos, int val) {",
			"        update(0, pos, 0, n-1, val);",
			"    }",
			"",
			"    void rangeUpdate(int l, int r, int val) {",
			"        rangeUpdate(0, l, r, 0, n-1, val);",
			"    }",
			"};"
		],
		"description": "Lazy Segment Tree 0-based"
	},

	"Segment Tree Lazy": {
		"prefix": "_lazy_segment_tree_add_1-based",
		"body": [
			"class SegmentTree { // 1-based index segment tree with lazy update",
			"private:",
			"    int n, tree[MAXN*4], lazy[MAXN*4];",
			"    vector<int> arr;",
			"",
			"    void build(int node, int tl, int tr) {",
			"        if (tl == tr) tree[node] = arr[tl];",
			"        else {",
			"            int tm = (tl + tr) >> 1;",
			"            build(node*2, tl, tm);",
			"            build(node*2+1, tm+1, tr);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"    int merge(int a, int b) {",
			"        return a + b; // sum segment tree",
			"    }",
			"",
			"    int query(int node, int l, int r, int tl, int tr) {",
			"        if (l > r) return 0;",
			"        if (l == tl && r == tr) return tree[node];",
			"        push(node, tl, tr);",
			"        int tm = (tl + tr) >> 1;",
			"        return merge(query(node*2, l, min(r, tm), tl, tm), query(node*2+1, max(l, tm+1), r, tm+1, tr));",
			"    }",
			"",
			"    void push(int node, int tl, int tr) {",
			"        if (lazy[node]) {",
			"            tree[node] += lazy[node] * (tr - tl + 1);",
			"            if (tl != tr) {",
			"                lazy[node*2] += lazy[node];",
			"                lazy[node*2+1] += lazy[node];",
			"            }",
			"            lazy[node] = 0;",
			"        }",
			"    }",
			"",
			"    void update(int node, int pos, int tl, int tr, int val) {",
			"        if (tl == tr) tree[node] += val;",
			"        else {",
			"            int tm = (tl + tr) >> 1;",
			"            push(node, tl, tr);",
			"            if (pos <= tm) update(node*2, pos, tl, tm, val);",
			"            else update(node*2+1, pos, tm+1, tr, val);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"    void rangeUpdate(int node, int l, int r, int tl, int tr, int val) {",
			"        if (l > r) return;",
			"        if (l == tl && r == tr) {",
			"            lazy[node] += val;",
			"            push(node, tl, tr);",
			"        } else {",
			"            int tm = (tl + tr) >> 1;",
			"            push(node, tl, tr);",
			"            rangeUpdate(node*2, l, min(r, tm), tl, tm, val);",
			"            rangeUpdate(node*2+1, max(l, tm+1), r, tm+1, tr, val);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"public:",
			"    SegmentTree(int sz) {",
			"        n = sz;",
			"        arr.resize(n+5, 0);",
			"    }",
			"",
			"    int query(int l, int r) {",
			"        return query(1, l, r, 1, n);",
			"    }",
			"",
			"    void update(int pos, int val) {",
			"        update(1, pos, 1, n, val);",
			"    }",
			"",
			"    void rangeUpdate(int l, int r, int val) {",
			"        rangeUpdate(1, l, r, 1, n, val);",
			"    }",
			"};",
			""
		],
	"description": "Segment Tree Lazy"
	},

	"Segment Tree Lazy Assign": {
		"prefix": "_lazy_segment_tree_assign",
		"body": [
			"class SegmentTree { // 1-based index segment tree with lazy update",
			"private:",
			"    int n, tree[MAXN*4], lazy[MAXN*4];",
			"    vector<int> arr;",
			"",
			"    void build(int node, int tl, int tr) {",
			"        if (tl == tr) tree[node] = arr[tl];",
			"        else {",
			"            int tm = (tl + tr) >> 1;",
			"            build(node*2, tl, tm);",
			"            build(node*2+1, tm+1, tr);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"    int merge(int a, int b) {",
			"        return a + b;",
			"    }",
			"",
			"    int query(int node, int l, int r, int tl, int tr) {",
			"        if (l > r) return 0;",
			"        if (l == tl && r == tr) return tree[node];",
			"        push(node, tl, tr);",
			"        int tm = (tl + tr) >> 1;",
			"        return merge(query(node*2, l, min(r, tm), tl, tm), query(node*2+1, max(l, tm+1), r, tm+1, tr));",
			"    }",
			"",
			"    void push(int node, int tl, int tr) {",
			"        if (lazy[node] != -1) {",
			"            tree[node] = lazy[node] * (tr - tl + 1);",
			"            if (tl != tr) {",
			"                lazy[node*2] = lazy[node];",
			"                lazy[node*2+1] = lazy[node];",
			"            }",
			"            lazy[node] = -1;",
			"        }",
			"    }",
			"",
			"    void update(int node, int pos, int tl, int tr, int val) {",
			"        if (tl == tr) tree[node] = val;",
			"        else {",
			"            int tm = (tl + tr) >> 1;",
			"            push(node, tl, tr);",
			"            if (pos <= tm) update(node*2, pos, tl, tm, val);",
			"            else update(node*2+1, pos, tm+1, tr, val);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"    void rangeUpdate(int node, int l, int r, int tl, int tr, int val) {",
			"        if (l > r) return;",
			"        if (l == tl && r == tr) {",
			"            lazy[node] = val;",
			"            push(node, tl, tr);",
			"        } else {",
			"            int tm = (tl + tr) >> 1;",
			"            push(node, tl, tr);",
			"            rangeUpdate(node*2, l, min(r, tm), tl, tm, val);",
			"            rangeUpdate(node*2+1, max(l, tm+1), r, tm+1, tr, val);",
			"            tree[node] = merge(tree[node*2], tree[node*2+1]);",
			"        }",
			"    }",
			"",
			"public:",
			"    SegmentTree(int sz) {",
			"        n = sz;",
			"        arr.resize(n+5, 0);",
			"        fill(lazy, lazy + 4 * n, -1);",
			"    }",
			"",
			"    int query(int l, int r) {",
			"        return query(1, l, r, 1, n);",
			"    }",
			"",
			"    void update(int pos, int val) {",
			"        update(1, pos, 1, n, val);",
			"    }",
			"",
			"    void rangeUpdate(int l, int r, int val) {",
			"        rangeUpdate(1, l, r, 1, n, val);",
			"    }",
			"};"
			],
		"description": "Segment Tree Lazy Assign"
	},

	"Difference Array": {
		"prefix": "_diff_array",
		"body": [
		  "int n, arr[MAXN], diff[MAXN];",
		  "",
		  "void update(int l, int r, int vl) {",
		  "    diff[l] += vl;",
		  "    if (r + 1 < n) diff[r] -= vl;",
		  "}",
		  "",
		  "void apply_update()",
		  "{",
		  "    for (int i=0; i<n; i++) diff[i] += diff[i-1];",
		  "    for (int i=0; i<n; i++) arr[i] += diff[i]; ",
		  "}"
		],
		"description": "Difference Array"
	},

	"For loop": {
		"prefix": "_for",
		"body": [
			"for (int i=0; i<n; i++) {}",
		],
		"description": "Loop For"
	},

	"Binary Exponentiation": {
		"prefix": "_binpow",
		"body": [
		  "int binpow(int a, int b, int mod) {",
		  "    if (a == 0) return 0;",
		  "    if (b == 1) return a;",
		  "",
		  "    int res = 1;",
		  "    while (b) {",
		  "        if (b & 1) res = (res * a) % mod;",
		  "        a = a * a % mod;",
		  "        b >>= 1;",
		  "    }",
		  "",
		  "    return res;",
		  "}"
		],
		"description": "Binary Exponentiation"
	},

	"Sparse Table": {
		"prefix": "_sparsetb",
		"body": [
			"class SparseTable {",
			"private:",
			"    vector<vector<long long>> st;",
			"    vector<long long> arr;",
			"    int n;",
			"",
			"    int merge(int a, int b) {",
			"        return a + b; // modify here",
			"    }",
			"",
			"public:",
			"    SparseTable(const vector<long long>& input) {",
			"        arr = input;",
			"        n = arr.size();",
			"        int max_log = std::log2(n) + 1;",
			"        st.assign(n, vector<long long>(max_log, 0));",
			"",
			"        for (int i = 0; i < n; ++i) {",
			"            st[i][0] = arr[i];",
			"        }",
			"",
			"        for (int j = 1; j < max_log; ++j) {",
			"            for (int i = 0; i + (1 << j) <= n; ++i) {",
			"                st[i][j] = merge(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
			"            }",
			"        }",
			"    }",
			"",
			"    long long query(int l, int r) {",
			"        long long sum = 0;",
			"        for (int j = std::log2(r - l + 1); j >= 0; --j) {",
			"            if (l + (1 << j) - 1 <= r) {",
			"                sum = merge(sum, st[l][j]);",
			"                l += (1 << j);",
			"            }",
			"        }",
			"        return sum;",
			"    }",
			"};"
		],
		"description": "Sparse Table"
	},

	"Fast Inout" : {
		"prefix": "_fastinout",
		"body": [
		"ios_base::sync_with_stdio(false);",
		"cin.tie(nullptr); cout.tie(nullptr);"
		],
	},

	"FreOpen" : {
		"prefix": "_freopen",
		"body": [
		"#ifdef LOCAL",
		"    freopen(\"in.txt\", \"r\", stdin);",
		"    freopen(\"ou.txt\", \"w\", stdout);",
		"#endif"
		],
	},

	"Fenwick Tree 0-based": {
		"prefix": "_fenwick_tree_range_0-based",
		"body": [
			"class FenwickTree {",
			"private:",
			"    std::vector<long long> BIT1, BIT2;",
			"    int n;",
			"    void update(std::vector<long long>& BIT, int index, long long value) {",
			"        while (index < n) {",
			"            BIT[index] += value;",
			"            index = index | (index + 1);",
			"        }",
			"    }",
			"    long long query(const std::vector<long long>& BIT, int index) {",
			"        long long sum = 0;",
			"        while (index >= 0) {",
			"            sum += BIT[index];",
			"            index = (index & (index + 1)) - 1;",
			"        }",
			"        return sum;",
			"    }",
			"public:",
			"    FenwickTree(int size) : n(size), BIT1(size, 0), BIT2(size, 0) {}",
			"    void rangeUpdate(int left, int right, long long value) {",
			"        update(BIT1, left, value);",
			"        if (right + 1 < n)",
			"            update(BIT1, right + 1, -value);",
			"        update(BIT2, left, value * left);",
			"        if (right + 1 < n)",
			"            update(BIT2, right + 1, -value * (right + 1));",
			"    }",
			"    long long prefixSum(int index) {",
			"        return query(BIT1, index) * (index + 1) - query(BIT2, index);",
			"    }",
			"    long long query(int left, int right) {",
			"        if (left == 0)",
			"            return prefixSum(right);",
			"        else",
			"            return prefixSum(right) - prefixSum(left - 1);",
			"    }",
			"};"
		],
		"description": "Fenwick Tree 0-based"
	},

	"Fenwick Tree Range Range": {
		"prefix": "_fenwick_tree_range_1-based",
		"body": [
			"class FenwickTree {",
			"private:",
			"    std::vector<long long> BIT1, BIT2;",
			"",
			"    void update(std::vector<long long> &BIT, int index, long long value) {",
			"        while (index < BIT.size()) {",
			"            BIT[index] += value;",
			"            index += index & (-index);",
			"        }",
			"    }",
			"",
			"    long long query(const std::vector<long long> &BIT, int index) {",
			"        long long sum = 0;",
			"        while (index > 0) {",
			"            sum += BIT[index];",
			"            index -= index & (-index);",
			"        }",
			"        return sum;",
			"    }",
			"",
			"public:",
			"    FenwickTree(int size) : BIT1(size + 1, 0), BIT2(size + 1, 0) {}",
			"",
			"    void rangeUpdate(int left, int right, long long value) {",
			"        update(BIT1, left, value);",
			"        update(BIT1, right + 1, -value);",
			"        update(BIT2, left, value * (left - 1));",
			"        update(BIT2, right + 1, -value * right);",
			"    }",
			"",
			"    long long prefixSum(int index) {",
			"        return query(BIT1, index) * index - query(BIT2, index);",
			"    }",
			"",
			"    long long rangeQuery(int left, int right) {",
			"        return prefixSum(right) - prefixSum(left - 1);",
			"    }",
			"};"
		],
		"description": "Fenwick Tree Range Range"
	},

	"Euler Tour": {
		"prefix": "_eulertour",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> startIdx, endIdx;",
			"int timer = 0;",
			"",
			"void euler_tour(int at, int prev) {",
			"    startIdx[at] = timer++;",
			"    for (int n : adj[at]) {",
			"        if (n != prev) { euler_tour(n, at); }",
			"    }",
			"    endIdx[at] = timer;",
			"}"
		],
		"description": "Euler Tour"
	},

	"Edmonds Karp": {
		"prefix": "_edmonds",
		"body": [
			"vector<vector<int>> adj, capacity;",
			"",
			"// Maximum Flow",
			"int bfs(int source, int stink, vector<int>& parent) {",
			"    fill(parent.begin(), parent.end(), -1);",
			"    parent[source] = -2;",
			"    queue<pair<int, int>> q;",
			"    q.push({source, INF});",
			"",
			"    while (!q.empty()) {",
			"        auto [u, flow] = q.front();",
			"        q.pop();",
			"",
			"        for (auto &v : adj[u]) {",
			"            if (parent[v] == -1 && capacity[u][v] > 0) {",
			"                parent[v] = u;",
			"                int new_flow = min(flow, capacity[u][v]);",
			"                if (v == stink) return new_flow;",
			"                q.push({v, new_flow});",
			"            }",
			"        } ",
			"    }",
			"",
			"    return 0;",
			"}",
			"",
			"int max_flow(int source, int stink, int total) {",
			"    int flow = 0;",
			"    vector<int> parent(total + 1);",
			"    int new_flow;",
			"",
			"    while (new_flow = bfs(source, stink, parent)) {",
			"        flow += new_flow;",
			"        int cur = stink;",
			"        while (cur != source) {",
			"            int prev = parent[cur];",
			"            capacity[prev][cur] -= new_flow;",
			"            capacity[cur][prev] += new_flow;",
			"            cur = prev;",
			"        }",
			"    }",
			"",
			"    return flow;",
			"}"
		],
		"description": "Edmonds Karp"
	},

	"Dinic": {
	"prefix": "_dinic",
	"body": [
		"struct Edge {",
    	"   int to, rev, cap;",
		"};",
		"",
		"class Dinic {",
		"public:",
		"    int n;",
		"    vector<vector<Edge>> adj;",
		"    vector<int> level, ptr;",
		" ",
		"    Dinic(int n): n(n), adj(n), level(n), ptr(n) {}",
		" ",
		"    void addEdge(int u, int v, int cap) {",
		"        Edge a = {v, (int) adj[v].size(), cap};",
		"        Edge b = {u, (int) adj[u].size(), 0};",
		"        adj[u].push_back(a);",
		"        adj[v].push_back(b);",
		"    }",
		" ",
		"    bool bfs(int s, int t) {",
		"        fill(level.begin(), level.end(), -1);",
		"",
		"        level[s] = 0;",
		"        queue<int> q;",
		"        q.push(s);",
		"",
		"        while (!q.empty()){",
		"            int u = q.front();",
		"            q.pop();",
		"            for (auto &e : adj[u]) {",
		"                if (level[e.to] < 0 && e.cap) {",
		"                    level[e.to] = level[u] + 1;",
		"                    q.push(e.to);",
		"                }",
		"            }",
		"        }",
		"",
		"        return level[t] >= 0;",
		"    }",
		" ",
		"    int dfs(int u, int t, int flow) {",
		"        if (!flow) return 0;",
		"        if (u == t) return flow;",
		"",
		"        for (int &i = ptr[u]; i < (int)adj[u].size(); i++){",
		"            Edge &e = adj[u][i];",
		"            if (level[e.to] != level[u] + 1 || e.cap == 0) continue;",
		"            int pushed = dfs(e.to, t, min(flow, e.cap));",
		"            if (pushed) {",
		"                e.cap -= pushed;",
		"                adj[e.to][e.rev].cap += pushed;",
		"                return pushed;",
		"            }",
		"        }",
		"",
		"        return 0;",
		"    }",
		" ",
		"    int maxFlow(int s, int t) {",
		"        int flow = 0;",
		"",
		"        while (bfs(s,t)) {",
		"            fill(ptr.begin(), ptr.end(), 0);",
		"            while (int pushed = dfs(s,t,INT_MAX))",
		"                flow += pushed;",
		"        }",
		"",
		"        return flow;",
		"    }",
		"};"
		],
		"description": "Dinic"
	},

	"Check Bipartite": {
		"prefix": "_bipartite",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> color;",
			"bool bipartite = true;",
			"",
			"void dfs(int u, int c) {",
			"    color[u] = c;",
			"    for (auto v : adj[u]) {",
			"        if (color[v] == -1) dfs(v, 1 - c);",
			"        else if (color[v] == color[u]) {",
			"            bipartite = false;",
			"        }",
			"    }",
			"}"
		],
		"description": "Check Bipartite"
	},

	"Maximum Matching 2 sides": {
		"prefix": "_bpm_n_m",
		"body": [
			"int maximum_matching(int n, int m, const vector<vector<int>>& adj) {",
			"    vector<int> matchL(n + 1, 0);",
			"    vector<int> matchR(n + m + 1, 0);",
			"    vector<int> dist(n + 1, INF);",
			"    ",
			"    auto bfs = [&]() -> bool {",
			"        queue<int> q;",
			"        for (int u=1; u<=n; u++) {",
			"            if (matchL[u] == 0) {",
			"                dist[u] = 0;",
			"                q.push(u);",
			"            } else {",
			"                dist[u] = INF;",
			"            }",
			"        }",
			"",
			"        dist[0] = INF;",
			"",
			"        while (!q.empty()) {",
			"            int u = q.front();",
			"            q.pop();",
			"",
			"            if (u == 0) continue;",
			"            for (int v : adj[u]) {",
			"                if (matchR[v] == 0) {",
			"                    dist[0] = dist[u] + 1;",
			"                } else if (dist[matchR[v]] == INF) {",
			"                    dist[matchR[v]] = dist[u] + 1;",
			"                    q.push(matchR[v]);",
			"                }",
			"            }",
			"        }",
			"        return dist[0] != INF;",
			"    };",
			"    ",
			"    function<bool(int)> dfs = [&](int u) -> bool {",
			"        if (u != 0) {",
			"            for (int v : adj[u]) {",
			"                if (matchR[v] == 0 || (dist[matchR[v]] == dist[u] + 1 && dfs(matchR[v]))) {",
			"                    matchL[u] = v;",
			"                    matchR[v] = u;",
			"                    return true;",
			"                }",
			"            }",
			"            dist[u] = INF;",
			"            return false;",
			"        }",
			"        return true;",
			"    };",
			"",
			"    function<int()> hopcroftKarp = [&] () -> int {",
			"        int matching = 0;",
			"        while (bfs()) {",
			"            for (int i=1; i<=n; i++) {",
			"                if (matchL[i] == 0 && dfs(i)) {",
			"                    matching++;",
			"                }",
			"            }",
			"        }",
			"        return matching;",
			"    };",
			"",
			"    return hopcroftKarp();",
			"}"
		],
		"description": "Maximum Matching 2 sides"
	},

	"Maximum Matching": {
		"prefix": "_bpm_n",
		"body": [
			"int maximum_matching(int n, const vector<vector<int>>& adj) {",
			"    vector<int> matchL(n + 1, 0);",
			"    vector<int> matchR(n + 1, 0);",
			"    vector<int> dist(n + 1, INF);",
			"    ",
			"    vector<int> side(n + 1, -1);",
			"    ",
			"    function<void(int)> dfs_color = [&](int u) {",
			"        queue<int> q;",
			"        q.push(u);",
			"        side[u] = 0;",
			"        while (!q.empty()) {",
			"            int v = q.front();",
			"            q.pop();",
			"            for (int nei : adj[v]) {",
			"                if (side[nei] == -1) {",
			"                    side[nei] = 1 - side[v];",
			"                    q.push(nei);",
			"                }",
			"            }",
			"        }",
			"    };",
			"",
			"    for (int i = 1; i <= n; i++) {",
			"        if (side[i] == -1) {",
			"            dfs_color(i);",
			"        }",
			"    }",
			"",
			"    auto bfs = [&]() -> bool {",
			"        queue<int> q;",
			"        for (int u = 1; u <= n; u++) {",
			"            if (side[u] == 0 && matchL[u] == 0) {",
			"                dist[u] = 0;",
			"                q.push(u);",
			"            } else {",
			"                dist[u] = INF;",
			"            }",
			"        }",
			"",
			"        dist[0] = INF;",
			"",
			"        while (!q.empty()) {",
			"            int u = q.front();",
			"            q.pop();",
			"",
			"            if (u == 0) continue;",
			"            for (int v : adj[u]) {",
			"                if (matchR[v] == 0) {",
			"                    dist[0] = dist[u] + 1;",
			"                } else if (dist[matchR[v]] == INF) {",
			"                    dist[matchR[v]] = dist[u] + 1;",
			"                    q.push(matchR[v]);",
			"                }",
			"            }",
			"        }",
			"        return dist[0] != INF;",
			"    };",
			"",
			"    function<bool(int)> dfs = [&](int u) -> bool {",
			"        if (u != 0) {",
			"            for (int v : adj[u]) {",
			"                if (matchR[v] == 0 || (dist[matchR[v]] == dist[u] + 1 && dfs(matchR[v]))) {",
			"                    matchL[u] = v;",
			"                    matchR[v] = u;",
			"                    return true;",
			"                }",
			"            }",
			"            dist[u] = INF;",
			"            return false;",
			"        }",
			"        return true;",
			"    };",
			"",
			"    function<int()> hopcroftKarp = [&]() -> int {",
			"        int matching = 0;",
			"        while (bfs()) {",
			"            for (int i = 1; i <= n; i++) {",
			"                if (side[i] == 0 && matchL[i] == 0 && dfs(i)) {",
			"                    matching++;",
			"                }",
			"            }",
			"        }",
			"        return matching;",
			"    };",
			"",
			"    return hopcroftKarp();",
			"}"
		],
		"description": "Maximum Matching"
	},

	"Floyd-Warshall": {
		"prefix": "_floyd",
		"body": [
			"vector<vector<int>> floyd(vector<vector<int>> dp, int n) {",
			"    for (int k=1; k<=n; k++) {",
			"        for (int i=1; i<=n; i++) {",
			"            if (dp[i][k] >= INF || i == k) continue;",
			"            for (int j=1; j<=n; j++) {",
			"                if (i == j || j == k) continue;",
			"                if (dp[i][k] < INF && dp[k][j] < INF) {",
			"                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    return dp;",
			"}"
		],
		"description": "Floyd-Warshall"
	},

	"Bellman-Ford": {
		"prefix": "_bell",
		"body": [
			"vector<int> bellmanFord(int n, const vector<tuple<int, int, int>>& edges, int source) {",
			"    vector<int> dist(n, INF);",
			"    dist[source] = 0;",
			"",
			"    for (int i=1; i<n; i++) {",
			"        for (auto &[u, v, w] : edges) {",
			"            if (dist[u] != INF && dist[u] + w < dist[v]) {",
			"                dist[v] = dist[u] + w;",
			"            }",
			"        }",
			"    }",
			"",
			"    for (auto &[u, v, w] : edges) {",
			"        if (dist[u] != INF && dist[u] + w < dist[v]) {",
			"            cout << \"Negative cycle\\n\";",
			"            return {};",
			"        }",
			"    }",
			"",
			"    return dist;",
			"}"
		],
		"description": "Bellman-Ford"
	},

	"Articulation Points Bridges": {
		"prefix": "_artpoint_bridge",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> dfs_num, dfs_low, articulation, parent;",
			"vector<pair<int, int>> bridges;",
			"int timer, n, m, rootChildren, root;",
			"",
			"void dfs(int u)",
			"{",
			"    dfs_num[u] = dfs_low[u] = timer++;",
			"",
			"    for (auto v : adj[u])",
			"    {",
			"        if (dfs_num[v] == -1) {",
			"            parent[v] = u;",
			"",
			"            if (u == root) ++rootChildren;",
			"",
			"            dfs(v);",
			"",
			"            if (dfs_low[v] >= dfs_num[u])",
			"                articulation[u] = 1;",
			"            if (dfs_low[v] > dfs_num[u]) {",
			"                bridges.push_back({u, v});",
			"            }",
			"",
			"            dfs_low[u] = min(dfs_low[u], dfs_low[v]);",
			"        } else if (v != parent[u]) {",
			"            dfs_low[u] = min(dfs_low[u], dfs_num[v]);",
			"        }",
			"    }",
			"}",
			"",
			"void find_bridges()",
			"{",
			"    timer = 0;",
			"    parent.resize(n + 1, -1);",
			"    dfs_low.resize(n + 1, 0);",
			"    dfs_num.resize(n + 1, -1);",
			"    articulation.resize(n + 1, 0);",
			"",
			"    for (int i=1; i<=n; i++) {",
			"        if (dfs_num[i] == -1) {",
			"            root = i, rootChildren = 0;",
			"            dfs(i);",
			"            articulation[root] = (rootChildren > 1);",
			"        }",
			"    }",
			"}"
		],
		"description": "Articulation Points Bridges"
	},
}